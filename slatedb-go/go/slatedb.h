/* WARNING: This file is auto-generated. Do not modify manually. */

#ifndef SLATEDB_GO_H
#define SLATEDB_GO_H

/* Generated with cbindgen:0.27.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef enum CSdbError {
    Success = 0,
    InvalidArgument = 1,
    NotFound = 2,
    AlreadyExists = 3,
    IOError = 4,
    InternalError = 5,
    NullPointer = 6,
    InvalidHandle = 7,
} CSdbError;

// Internal struct for managing database iterators in FFI
// Contains the iterator and a reference to the database to ensure proper lifetime management
typedef struct CSdbIterator CSdbIterator;

// Internal struct for managing WriteBatch operations in FFI
// Contains the WriteBatch that can be moved out when writing to the database
typedef struct CSdbWriteBatch CSdbWriteBatch;

// A builder for creating a new Db instance.
//
// This builder provides a fluent API for configuring and opening a SlateDB database.
// It separates the concerns of configuration options (settings) and components.
typedef struct DbBuilder_String DbBuilder_String;

// Internal struct that owns a Tokio runtime and a SlateDB DbReader instance.
// Similar to SlateDbFFI but for read-only operations.
typedef struct DbReaderFFI DbReaderFFI;

// Internal struct that owns a Tokio runtime and a SlateDB instance.
// This eliminates the need for a global handle map and shared runtime.
typedef struct SlateDbFFI SlateDbFFI;

typedef struct CSdbResult {
    enum CSdbError error;
    char *message;
} CSdbResult;

typedef struct CSdbPutOptions {
    // TTL type: 0=Default, 1=NoExpiry, 2=ExpireAfter
    uint32_t ttl_type;
    // TTL value in milliseconds (only used when ttl_type=2)
    uint64_t ttl_value;
} CSdbPutOptions;

// Type-safe wrapper around a pointer to SlateDbFFI.
// This provides better type safety than raw u64 handles.
typedef struct CSdbHandle {
    struct SlateDbFFI *_0;
} CSdbHandle;

typedef struct CSdbWriteOptions {
    bool await_durable;
} CSdbWriteOptions;

typedef struct CSdbReadOptions {
    // Durability filter: 0=Memory, 1=Remote
    uint32_t durability_filter;
    // Whether to include dirty/uncommitted data
    bool dirty;
} CSdbReadOptions;

typedef struct CSdbValue {
    uint8_t *data;
    uintptr_t len;
} CSdbValue;

typedef struct CSdbScanOptions {
    int32_t durability_filter;
    bool dirty;
    uint64_t read_ahead_bytes;
    bool cache_blocks;
    uint64_t max_fetch_tasks;
} CSdbScanOptions;

// Type-safe wrapper around a pointer to DbReaderFFI.
// This provides better type safety than raw pointers.
typedef struct CSdbReaderHandle {
    struct DbReaderFFI *_0;
} CSdbReaderHandle;

// DbReader options for FFI
typedef struct CSdbReaderOptions {
    // How often to poll for manifest updates (in milliseconds)
    uint64_t manifest_poll_interval_ms;
    // How long checkpoints should live (in milliseconds)
    uint64_t checkpoint_lifetime_ms;
    // Max size of in-memory table for WAL buffering
    uint64_t max_memtable_bytes;
} CSdbReaderOptions;

typedef struct CSdbKeyValue {
    struct CSdbValue key;
    struct CSdbValue value;
} CSdbKeyValue;

typedef struct CSdbScanResult {
    struct CSdbKeyValue *items;
    uintptr_t count;
    bool has_more;
    struct CSdbValue next_key;
} CSdbScanResult;

#define SsTableInfo_VT_FIRST_KEY 4

#define SsTableInfo_VT_INDEX_OFFSET 6

#define SsTableInfo_VT_INDEX_LEN 8

#define SsTableInfo_VT_FILTER_OFFSET 10

#define SsTableInfo_VT_FILTER_LEN 12

#define SsTableInfo_VT_COMPRESSION_FORMAT 14

#define BlockMeta_VT_OFFSET 4

#define SsTableIndex_VT_BLOCK_META 4

#define CompactedSstId_VT_HIGH 4

#define CompactedSstId_VT_LOW 6

#define CompactedSsTable_VT_ID 4

#define CompactedSsTable_VT_INFO 6

#define CompactedSsTable_VT_VISIBLE_RANGE 8

#define SortedRun_VT_SSTS 6

#define BytesBound_VT_KEY 4

#define BytesBound_VT_BOUND_TYPE 6

#define BytesRange_VT_START_BOUND 4

#define BytesRange_VT_END_BOUND 6

#define ExternalDb_VT_PATH 4

#define ExternalDb_VT_SOURCE_CHECKPOINT_ID 6

#define ExternalDb_VT_FINAL_CHECKPOINT_ID 8

#define ExternalDb_VT_SST_IDS 10

#define ManifestV1_VT_MANIFEST_ID 4

#define ManifestV1_VT_EXTERNAL_DBS 6

#define ManifestV1_VT_INITIALIZED 8

#define ManifestV1_VT_WRITER_EPOCH 10

#define ManifestV1_VT_COMPACTOR_EPOCH 12

#define ManifestV1_VT_REPLAY_AFTER_WAL_ID 14

#define ManifestV1_VT_WAL_ID_LAST_SEEN 16

#define ManifestV1_VT_L0_LAST_COMPACTED 18

#define ManifestV1_VT_L0 20

#define ManifestV1_VT_COMPACTED 22

#define ManifestV1_VT_LAST_L0_CLOCK_TICK 24

#define ManifestV1_VT_CHECKPOINTS 26

#define ManifestV1_VT_LAST_L0_SEQ 28

#define ManifestV1_VT_WAL_OBJECT_STORE_URI 30

#define ManifestV1_VT_RECENT_SNAPSHOT_MIN_SEQ 32

#define ManifestV1_VT_SEQUENCE_TRACKER 34

#define WriterCheckpoint_VT_EPOCH 4

#define Checkpoint_VT_CHECKPOINT_EXPIRE_TIME_S 8

#define Checkpoint_VT_CHECKPOINT_CREATE_TIME_S 10

#define Checkpoint_VT_METADATA_TYPE 12

#define Checkpoint_VT_METADATA 14

// Initialize logging for SlateDB Go bindings
// This should be called once before using any other SlateDB functions
//
// # Safety
//
// - `level` must be a valid C string pointer or null for default level
struct CSdbResult slatedb_init_logging(const char *level);

// Create default Settings and return as JSON string
char *slatedb_settings_default(void);

// Load Settings from file and return as JSON string
char *slatedb_settings_from_file(const char *path);

// Load Settings from environment variables and return as JSON string
char *slatedb_settings_from_env(const char *prefix);

// Load Settings using auto-detection and return as JSON string
char *slatedb_settings_load(void);

// # Safety
//
// - `batch_out` must be a valid pointer to a location where a batch pointer can be stored
struct CSdbResult slatedb_write_batch_new(struct CSdbWriteBatch **batch_out);

// # Safety
//
// - `batch` must be a valid pointer to a WriteBatch
// - `key` must point to valid memory of at least `key_len` bytes
// - `value` must point to valid memory of at least `value_len` bytes
struct CSdbResult slatedb_write_batch_put(struct CSdbWriteBatch *batch,
                                          const uint8_t *key,
                                          uintptr_t key_len,
                                          const uint8_t *value,
                                          uintptr_t value_len);

// # Safety
//
// - `batch` must be a valid pointer to a WriteBatch
// - `key` must point to valid memory of at least `key_len` bytes
// - `value` must point to valid memory of at least `value_len` bytes
// - `options` must be a valid pointer to CSdbPutOptions or null
struct CSdbResult slatedb_write_batch_put_with_options(struct CSdbWriteBatch *batch,
                                                       const uint8_t *key,
                                                       uintptr_t key_len,
                                                       const uint8_t *value,
                                                       uintptr_t value_len,
                                                       const struct CSdbPutOptions *options);

// # Safety
//
// - `batch` must be a valid pointer to a WriteBatch
// - `key` must point to valid memory of at least `key_len` bytes
struct CSdbResult slatedb_write_batch_delete(struct CSdbWriteBatch *batch,
                                             const uint8_t *key,
                                             uintptr_t key_len);

// # Safety
//
// - `handle` must contain a valid database handle pointer
// - `batch` must be a valid pointer to a WriteBatch
// - `options` must be a valid pointer to CSdbWriteOptions or null
struct CSdbResult slatedb_write_batch_write(struct CSdbHandle handle,
                                            struct CSdbWriteBatch *batch,
                                            const struct CSdbWriteOptions *options);

// # Safety
//
// - `batch` must be a valid pointer to a WriteBatch that was previously allocated
struct CSdbResult slatedb_write_batch_close(struct CSdbWriteBatch *batch);

struct CSdbHandle slatedb_open(const char *path, const char *store_config_json);

// # Safety
//
// - `handle` must contain a valid database handle pointer
// - `key` must point to valid memory of at least `key_len` bytes
// - `value` must point to valid memory of at least `value_len` bytes
// - `put_options` must be a valid pointer to CSdbPutOptions or null
// - `write_options` must be a valid pointer to CSdbWriteOptions or null
struct CSdbResult slatedb_put_with_options(struct CSdbHandle handle,
                                           const uint8_t *key,
                                           uintptr_t key_len,
                                           const uint8_t *value,
                                           uintptr_t value_len,
                                           const struct CSdbPutOptions *put_options,
                                           const struct CSdbWriteOptions *write_options);

// # Safety
//
// - `handle` must contain a valid database handle pointer
// - `key` must point to valid memory of at least `key_len` bytes
// - `write_options` must be a valid pointer to CSdbWriteOptions or null
struct CSdbResult slatedb_delete_with_options(struct CSdbHandle handle,
                                              const uint8_t *key,
                                              uintptr_t key_len,
                                              const struct CSdbWriteOptions *write_options);

// # Safety
//
// - `handle` must contain a valid database handle pointer
// - `key` must point to valid memory of at least `key_len` bytes
// - `read_options` must be a valid pointer to CSdbReadOptions or null
// - `value_out` must be a valid pointer to a location where a value can be stored
struct CSdbResult slatedb_get_with_options(struct CSdbHandle handle,
                                           const uint8_t *key,
                                           uintptr_t key_len,
                                           const struct CSdbReadOptions *read_options,
                                           struct CSdbValue *value_out);

struct CSdbResult slatedb_flush(struct CSdbHandle handle);

struct CSdbResult slatedb_close(struct CSdbHandle handle);

// # Safety
//
// - `handle` must contain a valid database handle pointer
// - `start_key` must point to valid memory of at least `start_key_len` bytes (if not null)
// - `end_key` must point to valid memory of at least `end_key_len` bytes (if not null)
// - `scan_options` must be a valid pointer to CSdbScanOptions or null
// - `iterator_ptr` must be a valid pointer to a location where an iterator pointer can be stored
struct CSdbResult slatedb_scan_with_options(struct CSdbHandle handle,
                                            const uint8_t *start_key,
                                            uintptr_t start_key_len,
                                            const uint8_t *end_key,
                                            uintptr_t end_key_len,
                                            const struct CSdbScanOptions *scan_options,
                                            struct CSdbIterator **iterator_ptr);

// Create a new DbBuilder
struct DbBuilder_String *slatedb_builder_new(const char *path, const char *store_config_json);

// Set settings on DbBuilder from JSON
//
// # Safety
//
// - `builder` must be a valid pointer to a DbBuilder
// - `settings_json` must be a valid C string pointer
bool slatedb_builder_with_settings(struct DbBuilder_String *builder, const char *settings_json);

// Set SST block size on DbBuilder
//
// # Safety
//
// - `builder` must be a valid pointer to a DbBuilder
bool slatedb_builder_with_sst_block_size(struct DbBuilder_String *builder, uint8_t size);

// Build the database from DbBuilder
//
// # Safety
//
// - `builder` must be a valid pointer to a DbBuilder that was previously allocated
struct CSdbHandle slatedb_builder_build(struct DbBuilder_String *builder);

// Free DbBuilder
//
// # Safety
//
// - `builder` must be a valid pointer to a DbBuilder that was previously allocated
void slatedb_builder_free(struct DbBuilder_String *builder);

struct CSdbReaderHandle slatedb_reader_open(const char *path,
                                            const char *store_config_json,
                                            const char *checkpoint_id,
                                            const struct CSdbReaderOptions *reader_options);

// # Safety
//
// - `handle` must contain a valid reader handle pointer
// - `key` must point to valid memory of at least `key_len` bytes
// - `read_options` must be a valid pointer to CSdbReadOptions or null
// - `value_out` must be a valid pointer to a location where a value can be stored
struct CSdbResult slatedb_reader_get_with_options(struct CSdbReaderHandle handle,
                                                  const uint8_t *key,
                                                  uintptr_t key_len,
                                                  const struct CSdbReadOptions *read_options,
                                                  struct CSdbValue *value_out);

// # Safety
//
// - `handle` must contain a valid reader handle pointer
// - `start_key` must point to valid memory of at least `start_key_len` bytes (if not null)
// - `end_key` must point to valid memory of at least `end_key_len` bytes (if not null)
// - `scan_options` must be a valid pointer to CSdbScanOptions or null
// - `iterator_ptr` must be a valid pointer to a location where an iterator pointer can be stored
struct CSdbResult slatedb_reader_scan_with_options(struct CSdbReaderHandle handle,
                                                   const uint8_t *start_key,
                                                   uintptr_t start_key_len,
                                                   const uint8_t *end_key,
                                                   uintptr_t end_key_len,
                                                   const struct CSdbScanOptions *scan_options,
                                                   struct CSdbIterator **iterator_ptr);

struct CSdbResult slatedb_reader_close(struct CSdbReaderHandle handle);

// # Safety
//
// - `iter` must be a valid pointer to a CSdbIterator
// - `kv_out` must be a valid pointer to a location where a key-value pair can be stored
struct CSdbResult slatedb_iterator_next(struct CSdbIterator *iter, struct CSdbKeyValue *kv_out);

// # Safety
//
// - `iter` must be a valid pointer to a CSdbIterator
// - `key` must point to valid memory of at least `key_len` bytes
struct CSdbResult slatedb_iterator_seek(struct CSdbIterator *iter,
                                        const uint8_t *key,
                                        uintptr_t key_len);

// # Safety
//
// - `iter` must be a valid pointer to a CSdbIterator that was previously allocated
struct CSdbResult slatedb_iterator_close(struct CSdbIterator *iter);

void slatedb_free_result(struct CSdbResult result);

void slatedb_free_value(struct CSdbValue value);

void slatedb_free_scan_result(struct CSdbScanResult result);

#endif  /* SLATEDB_GO_H */
