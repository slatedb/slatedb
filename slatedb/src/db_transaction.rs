use bytes::Bytes;
use parking_lot::Mutex;
use std::collections::HashSet;
use std::ops::RangeBounds;
use std::sync::Arc;
use uuid::Uuid;

use crate::batch::WriteBatch;
use crate::bytes_range::BytesRange;
use crate::config::{PutOptions, ReadOptions, ScanOptions, WriteOptions};
use crate::db::DbInner;
use crate::db_iter::{DbIterator, DbIteratorRangeTracker};
use crate::error::SlateDBError;
use crate::transaction_manager::{IsolationLevel, TransactionManager};
use crate::DbRead;

/// A database transaction that provides atomic read-write operations with
/// configurable isolation levels. This is the main interface for transactional
/// operations in SlateDB.
///
/// # Examples
///
/// Basic transaction usage:
/// ```rust
/// # async fn run() -> Result<(), slatedb::Error> {
/// #     use std::sync::Arc;
/// #     use slatedb::object_store::memory::InMemory;
/// use slatedb::{Db, IsolationLevel};
///
/// #     let object_store = Arc::new(InMemory::new());
/// #     let db = Db::open("path/to/db", object_store).await?;
/// let mut txn = db.begin_transaction(IsolationLevel::Snapshot).await?;
///
/// // Read operations
/// let value = txn.get(b"key").await?;
///
/// // Write operations
/// txn.put(b"key", b"value")?;
/// txn.delete(b"key")?;
///
/// // Commit the transaction
/// txn.commit().await?;
/// # Ok(())
/// # };
/// ```
pub struct DBTransaction {
    /// Transaction ID generated by the transaction manager
    txn_id: Uuid,
    /// Sequence number when the transaction started
    started_seq: u64,
    /// Reference to the transaction manager
    txn_manager: Arc<TransactionManager>,
    /// The write batch of the transaction, which contains the uncommitted writes.
    /// Users can read data from the write batch during the transaction,
    /// thus providing an MVCC view of the database.
    write_batch: WriteBatch,
    /// Reference to the database
    db_inner: Arc<DbInner>,
    /// Isolation level for this transaction
    isolation_level: IsolationLevel,
    /// Range trackers for scanned ranges (used for SSI conflict detection)
    range_trackers: Mutex<Vec<Arc<DbIteratorRangeTracker>>>,
}

impl DBTransaction {
    #[allow(unused)]
    pub(crate) fn new(
        db_inner: Arc<DbInner>,
        txn_manager: Arc<TransactionManager>,
        seq: u64,
        isolation_level: IsolationLevel,
    ) -> Self {
        let txn_id = txn_manager.new_txn(seq, false); // false = not read-only

        Self {
            txn_id,
            started_seq: seq,
            txn_manager,
            write_batch: WriteBatch::new(),
            db_inner,
            isolation_level,
            range_trackers: Mutex::new(Vec::new()),
        }
    }

    /// Get a value from the transaction with default read options.
    /// This operation will track the read for conflict detection in SSI mode.
    ///
    /// ## Arguments
    /// - `key`: the key to get
    ///
    /// ## Returns
    /// - `Result<Option<Bytes>, SlateDBError>`: the value if it exists, None otherwise
    pub async fn get<K: AsRef<[u8]> + Send>(&self, key: K) -> Result<Option<Bytes>, crate::Error> {
        self.get_with_options(key, &ReadOptions::default()).await
    }

    /// Get a value from the transaction with custom read options.
    /// This operation will track the read for conflict detection in SSI mode.
    ///
    /// ## Arguments
    /// - `key`: the key to get
    /// - `options`: the read options to use
    ///
    /// ## Returns
    /// - `Result<Option<Bytes>, SlateDBError>`: the value if it exists, None otherwise
    pub async fn get_with_options<K: AsRef<[u8]> + Send>(
        &self,
        key: K,
        options: &ReadOptions,
    ) -> Result<Option<Bytes>, crate::Error> {
        self.db_inner.check_error()?;

        // Track read key for SSI conflict detection if needed
        if self.isolation_level == IsolationLevel::SerializableSnapshot {
            let key_bytes = Bytes::copy_from_slice(key.as_ref());
            let mut read_keys = HashSet::new();
            read_keys.insert(key_bytes);
            self.txn_manager.track_read_keys(&self.txn_id, &read_keys);
        }

        let db_state = self.db_inner.state.read().view();

        // TODO: Implement proper write batch integration in the reader
        // For now, delegate to the underlying reader
        self.db_inner
            .reader
            .get_with_options(
                key,
                options,
                &db_state,
                Some(&self.write_batch),
                Some(self.started_seq),
            )
            .await
            .map_err(Into::into)
    }

    /// Scan a range of keys using the default scan options.
    /// This operation will track the read range for conflict detection in SSI mode.
    ///
    /// ## Arguments
    /// - `range`: the range of keys to scan
    ///
    /// ## Returns
    /// - `Result<DbIterator, SlateDBError>`: An iterator with the results of the scan
    pub async fn scan<K, T>(&self, range: T) -> Result<DbIterator, crate::Error>
    where
        K: AsRef<[u8]> + Send,
        T: RangeBounds<K> + Send,
    {
        self.scan_with_options(range, &ScanOptions::default()).await
    }

    /// Scan a range of keys with the provided options.
    /// This operation will track the read range for conflict detection in SSI mode.
    ///
    /// ## Arguments
    /// - `range`: the range of keys to scan
    /// - `options`: the scan options to use
    ///
    /// ## Returns
    /// - `Result<DbIterator, SlateDBError>`: An iterator with the results of the scan
    pub async fn scan_with_options<K, T>(
        &self,
        range: T,
        options: &ScanOptions,
    ) -> Result<DbIterator, crate::Error>
    where
        K: AsRef<[u8]> + Send,
        T: RangeBounds<K> + Send,
    {
        // TODO: this range conversion logic can be extract to an util
        let start = range
            .start_bound()
            .map(|b| Bytes::copy_from_slice(b.as_ref()));
        let end = range
            .end_bound()
            .map(|b| Bytes::copy_from_slice(b.as_ref()));
        let range = (start, end);

        // Track read range for SSI conflict detection if needed
        let range_tracker = if self.isolation_level == IsolationLevel::SerializableSnapshot {
            let tracker = Arc::new(DbIteratorRangeTracker::new());
            self.range_trackers.lock().push(tracker.clone());
            Some(tracker)
        } else {
            None
        };

        self.db_inner.check_error()?;
        let db_state = self.db_inner.state.read().view();

        // TODO: Implement proper write batch integration in the reader
        // For now, delegate to the underlying reader
        self.db_inner
            .reader
            .scan_with_options(
                BytesRange::from(range),
                options,
                &db_state,
                Some(&self.write_batch),
                Some(self.started_seq),
                range_tracker,
            )
            .await
            .map_err(Into::into)
    }

    /// Put a key-value pair into the transaction.
    /// The write will be buffered in the transaction's write batch until commit.
    ///
    /// ## Arguments
    /// - `key`: the key to write
    /// - `value`: the value to write
    ///
    /// ## Errors
    /// - `Error`: if there was an error buffering the write
    pub fn put<K, V>(&mut self, key: K, value: V) -> Result<(), crate::Error>
    where
        K: AsRef<[u8]>,
        V: AsRef<[u8]>,
    {
        self.put_with_options(key, value, &PutOptions::default())
    }

    /// Put a key-value pair into the transaction with custom options.
    /// The write will be buffered in the transaction's write batch until commit.
    ///
    /// ## Arguments
    /// - `key`: the key to write
    /// - `value`: the value to write
    /// - `options`: the put options to use
    ///
    /// ## Errors
    /// - `Error`: if there was an error buffering the write
    pub fn put_with_options<K, V>(
        &mut self,
        key: K,
        value: V,
        options: &PutOptions,
    ) -> Result<(), crate::Error>
    where
        K: AsRef<[u8]>,
        V: AsRef<[u8]>,
    {
        self.write_batch.put_with_options(key, value, options);
        Ok(())
    }

    /// Delete a key from the transaction.
    /// The delete will be buffered in the transaction's write batch until commit.
    ///
    /// ## Arguments
    /// - `key`: the key to delete
    ///
    /// ## Errors
    /// - `Error`: if there was an error buffering the delete
    pub fn delete<K: AsRef<[u8]>>(&mut self, key: K) -> Result<(), crate::Error> {
        self.write_batch.delete(key);
        Ok(())
    }

    /// Commit the transaction by writing all buffered operations to the database.
    ///
    /// ## Errors
    /// - `Error`: if there was an error committing the transaction
    pub async fn commit(self) -> Result<(), crate::Error> {
        // Extract actual scanned ranges from trackers for SSI conflict detection
        if self.isolation_level == IsolationLevel::SerializableSnapshot {
            for tracker in self.range_trackers.lock().iter() {
                if tracker.has_data() {
                    if let Some(range) = tracker.get_range() {
                        self.txn_manager.track_read_range(&self.txn_id, range);
                    }
                }
            }
        }

        // Check for conflicts before committing
        if self.txn_manager.check_has_conflict(&self.txn_id) {
            return Err(crate::Error::from(SlateDBError::TransactionConflict));
        }

        // Write the transaction's batch to the database
        self.db_inner
            .write_with_options(self.write_batch.clone(), &WriteOptions::default())
            .await
            .map_err(Into::into)
    }

    /// Rollback the transaction by discarding all buffered operations.
    /// This is automatically called when the transaction is dropped.
    pub fn rollback(self) {
        // do nothing, trigger the Drop of the transaction
    }
}

#[async_trait::async_trait]
impl DbRead for DBTransaction {
    async fn get_with_options<K: AsRef<[u8]> + Send>(
        &self,
        key: K,
        options: &ReadOptions,
    ) -> Result<Option<Bytes>, crate::Error> {
        self.get_with_options(key, options).await
    }

    async fn scan_with_options<K, T>(
        &self,
        range: T,
        options: &ScanOptions,
    ) -> Result<DbIterator, crate::Error>
    where
        K: AsRef<[u8]> + Send,
        T: RangeBounds<K> + Send,
    {
        self.scan_with_options(range, options).await
    }
}

/// Unregister from transaction manager when dropped.
/// If the transaction hasn't been committed, it's considered rolled back.
impl Drop for DBTransaction {
    fn drop(&mut self) {
        self.txn_manager.drop_txn(&self.txn_id);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::object_store::memory::InMemory;
    use rstest::rstest;
    use std::sync::Arc;

    #[tokio::test]
    async fn test_txn_basic_visibility() {
        // Setup database with initial data
        let object_store: Arc<dyn object_store::ObjectStore> = Arc::new(InMemory::new());
        let db = crate::Db::open("test_db", object_store).await.unwrap();

        // Put initial data
        db.put(b"k1", b"v1").await.unwrap();

        // Begin transaction
        let txn = db
            .begin_transaction(IsolationLevel::Snapshot)
            .await
            .unwrap();

        // Put data from others
        db.put(b"k2", b"v2").await.unwrap();

        // Read within transaction - should see the initial data
        let value = txn.get(b"k1").await.unwrap();
        assert_eq!(value, Some(Bytes::from_static(b"v1")));

        // Commit transaction
        txn.commit().await.unwrap();
    }

    #[tokio::test]
    async fn test_txn_write_visibility_in_txn() {
        // Setup database with initial data
        let object_store: Arc<dyn object_store::ObjectStore> = Arc::new(InMemory::new());
        let db = crate::Db::open("test_db", object_store).await.unwrap();

        // Put initial data
        db.put(b"k1", b"v1").await.unwrap();

        // Begin transaction
        let mut txn = db
            .begin_transaction(IsolationLevel::SerializableSnapshot)
            .await
            .unwrap();

        // Write within transaction
        txn.put(b"k1", b"v2").unwrap();

        // Read within transaction - should see the updated value in the transaction
        let value = txn.get(b"k1").await.unwrap();
        assert_eq!(value, Some(Bytes::from_static(b"v2")));

        // Commit transaction
        txn.commit().await.unwrap();
    }

    #[tokio::test]
    async fn test_txn_si_commit_conflict() {
        // Setup database with initial data
        let object_store: Arc<dyn object_store::ObjectStore> = Arc::new(InMemory::new());
        let db = crate::Db::open("test_db", object_store).await.unwrap();

        // Put initial data
        db.put(b"k1", b"v1").await.unwrap();

        // Begin first transaction
        let mut txn1 = db
            .begin_transaction(IsolationLevel::Snapshot)
            .await
            .unwrap();
        txn1.put(b"k1", b"v2").unwrap();

        // Begin second transaction
        let mut txn2 = db
            .begin_transaction(IsolationLevel::Snapshot)
            .await
            .unwrap();
        txn2.put(b"k1", b"v3").unwrap();

        // Commit first transaction - should succeed
        txn1.commit().await.unwrap();

        // Commit second transaction - should fail due to conflict
        let result = txn2.commit().await;
        assert!(result.is_err());
    }

    // Transaction test structures for table-driven tests
    #[derive(Debug, Clone)]
    struct TransactionTestCase {
        name: &'static str,
        initial_data: Vec<(&'static str, &'static str)>,
        operations: Vec<TransactionTestOp>,
        expected_results: Vec<TransactionTestOpResult>,
    }

    #[derive(Debug, Clone)]
    #[allow(dead_code)]
    enum TransactionTestOp {
        TxnGet(&'static str),
        TxnPut(&'static str, &'static str),
        TxnDelete(&'static str),
        DbPut(&'static str, &'static str),
        DbGet(&'static str),
        Commit,
        Rollback,
    }

    #[derive(Debug, Clone, PartialEq)]
    enum TransactionTestOpResult {
        GotValue(Option<String>),
        Empty,
        Conflicted,
        Invalid,
    }

    async fn execute_transaction_test(test_case: TransactionTestCase) {
        let object_store: Arc<dyn object_store::ObjectStore> = Arc::new(InMemory::new());
        let db = crate::Db::open(test_case.name, object_store).await.unwrap();

        // Setup initial data
        for (key, value) in test_case.initial_data {
            db.put(key, value).await.unwrap();
        }

        let mut txn_opt = Some(
            db.begin_transaction(IsolationLevel::SerializableSnapshot)
                .await
                .unwrap(),
        );

        for (i, operation) in test_case.operations.iter().enumerate() {
            let result = match txn_opt.as_ref() {
                Some(_) => match operation {
                    TransactionTestOp::TxnGet(key) => {
                        let txn = txn_opt.as_ref().unwrap();
                        let val = txn.get(key).await.unwrap();
                        TransactionTestOpResult::GotValue(
                            val.and_then(|b| String::from_utf8(b.to_vec()).ok()),
                        )
                    }
                    TransactionTestOp::TxnPut(key, value) => {
                        let txn = txn_opt.as_mut().unwrap();
                        txn.put(key, value).unwrap();
                        TransactionTestOpResult::Empty
                    }
                    TransactionTestOp::TxnDelete(key) => {
                        let txn = txn_opt.as_mut().unwrap();
                        txn.delete(key).unwrap();
                        TransactionTestOpResult::Empty
                    }
                    TransactionTestOp::Commit => {
                        let txn = txn_opt.take().unwrap();
                        match txn.commit().await {
                            Ok(_) => TransactionTestOpResult::Empty,
                            Err(_) => TransactionTestOpResult::Conflicted,
                        }
                    }
                    TransactionTestOp::Rollback => {
                        let txn = txn_opt.take().unwrap();
                        txn.rollback();
                        TransactionTestOpResult::Empty
                    }
                    TransactionTestOp::DbPut(key, value) => {
                        db.put(key, value).await.unwrap();
                        TransactionTestOpResult::Empty
                    }
                    TransactionTestOp::DbGet(key) => {
                        let val = db.get(key).await.unwrap();
                        TransactionTestOpResult::GotValue(
                            val.and_then(|b| String::from_utf8(b.to_vec()).ok()),
                        )
                    }
                },
                None => match operation {
                    TransactionTestOp::DbPut(key, value) => {
                        db.put(key, value).await.unwrap();
                        TransactionTestOpResult::Empty
                    }
                    TransactionTestOp::DbGet(key) => {
                        let val = db.get(key).await.unwrap();
                        TransactionTestOpResult::GotValue(
                            val.and_then(|b| String::from_utf8(b.to_vec()).ok()),
                        )
                    }
                    _ => TransactionTestOpResult::Invalid,
                },
            };

            let expected = &test_case.expected_results[i];
            assert_eq!(
                result, *expected,
                "Test '{}' failed at operation {}: expected {:?}, got {:?}",
                test_case.name, i, expected, result
            );
        }
    }

    // Table-driven tests using rstest
    #[rstest]
    #[case::si_basic_visibility(
        TransactionTestCase {
            name: "si_basic_visibility",
            initial_data: vec![("k1", "v1")],
            operations: vec![
                TransactionTestOp::TxnGet("k1"),
                TransactionTestOp::Commit,
            ],
            expected_results: vec![
                TransactionTestOpResult::GotValue(Some("v1".to_string())),
                TransactionTestOpResult::Empty,
            ]
        }
    )]
    #[case::si_write_visibility_in_txn(
        TransactionTestCase {
            name: "si_write_visibility_in_txn",
            initial_data: vec![("k1", "v1")],
            operations: vec![
                TransactionTestOp::TxnPut("k1", "v2"),
                TransactionTestOp::TxnGet("k1"),
                TransactionTestOp::Commit,
            ],
            expected_results: vec![
                TransactionTestOpResult::Empty,
                TransactionTestOpResult::GotValue(Some("v2".to_string())),
                TransactionTestOpResult::Empty,
            ]
        }
    )]
    #[case::si_delete_visibility_in_txn(
        TransactionTestCase {
            name: "si_delete_visibility_in_txn",
            initial_data: vec![("k1", "v1")],
            operations: vec![
                TransactionTestOp::TxnDelete("k1"),
                TransactionTestOp::TxnGet("k1"),
                TransactionTestOp::Commit,
            ],
            expected_results: vec![
                TransactionTestOpResult::Empty,
                TransactionTestOpResult::GotValue(None),
                TransactionTestOpResult::Empty,
            ]
        }
    )]
    #[case::si_rollback_visibility(
        TransactionTestCase {
            name: "si_rollback_visibility",
            initial_data: vec![("k1", "v1")],
            operations: vec![
                TransactionTestOp::TxnPut("k1", "v2"),
                TransactionTestOp::Rollback,
                TransactionTestOp::DbGet("k1"),
            ],
            expected_results: vec![
                TransactionTestOpResult::Empty,
                TransactionTestOpResult::Empty,
                TransactionTestOpResult::GotValue(Some("v1".to_string())),
            ]
        }
    )]
    #[tokio::test]
    async fn test_si_table_driven(#[case] test_case: TransactionTestCase) {
        execute_transaction_test(test_case).await;
    }
}
