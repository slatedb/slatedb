---
deadlock_detection: false
options:
    max_actions: 50
    crash_on_yield: false
action_options:
    KeyValueStore.Put:
        max_actions: 10
    KeyValueStore.Get:
        max_actions: 5
    KeyValueStore.FlushWAL:
        max_concurrent_actions: 1
    KeyValueStore.FreezeMemtable:
        max_concurrent_actions: 1
    KeyValueStore.FlushMemtableToL0:
        max_concurrent_actions: 1
---

# Constants
KEYS = ["k0", "k1"]
VALUES = ["v0", "v1", ""]

DURABILITY_MEMORY = 0
DURABILITY_REMOTE = 2

role KeyValueStore:
    action Init:
        self.wal_buffer = []
        self.flushed_wal = []
        self.memtable = []
        self.immutable_memtable = []
        self.l0 = []
        self.last_committed_seq = 0
        self.last_remote_persisted_seq = 0
        self.next_seq = 1

    # Get operation - reads the most recent value for a key
    action Get:
        key = any KEYS
        dirty = any [true, false]  # Whether to allow reading uncommitted data
        durability_filter = any [DURABILITY_MEMORY, DURABILITY_REMOTE]
        
        # Calculate maximum readable sequence number
        max_seq = none
        if durability_filter == DURABILITY_REMOTE:
            max_seq = self.last_remote_persisted_seq

        if not dirty:
            if max_seq == none:
                max_seq = self.last_committed_seq
            else:
                if self.last_committed_seq < max_seq:
                    max_seq = self.last_committed_seq
        
        # Search in memtable (most recent first)
        for entry in reversed(self.memtable):
            if entry[0] == key:
                if max_seq == none or entry[2] <= max_seq:
                    return entry[1]
        
        # Search in immutable memtable
        for entry in reversed(self.immutable_memtable):
            if entry[0] == key:
                if max_seq == none or entry[2] <= max_seq:
                    return entry[1]
        
        # Search in L0 levels (most recent first)
        for level in reversed(self.l0):
            for entry in reversed(level):
                if entry[0] == key:
                    if max_seq == none or entry[2] <= max_seq:
                        return entry[1]
        
        return ""

    # Put operation - writes a key-value pair
    action Put:
        require self.next_seq <= 20  # Limit sequence numbers
        key = any KEYS
        value = any VALUES
        sync = any [DURABILITY_MEMORY, DURABILITY_REMOTE]

        seq = self.next_seq
        self.next_seq = self.next_seq + 1
        
        # Add to WAL buffer
        self.wal_buffer = self.wal_buffer + [(key, value, seq)]
        
        # Add to memtable
        self.memtable = self.memtable + [(key, value, seq)]
        
        # If sync is REMOTE, flush WAL immediately
        if sync == DURABILITY_REMOTE:
            self.doFlushWAL()
 
        # Update committed sequence
        self.last_committed_seq = seq

    # Flush WAL to remote storage
    atomic action FlushWAL:
        require len(self.wal_buffer) > 0
        self.doFlushWAL()

    # Freeze memtable to immutable memtable
    atomic action FreezeMemtable:
        require len(self.memtable) > 0
        self.immutable_memtable = self.immutable_memtable + self.memtable
        self.memtable = []

    # Flush immutable memtable to L0
    atomic action FlushMemtableToL0:
        require len(self.immutable_memtable) > 0
        self.l0 = self.l0 + [self.immutable_memtable]
        self.immutable_memtable = []

    # Helper function to flush WAL
    fun doFlushWAL():
        self.flushed_wal = self.flushed_wal + self.wal_buffer
        self.wal_buffer = []
        if len(self.flushed_wal) > 0:
            self.last_remote_persisted_seq = self.flushed_wal[-1][2]

# Initialize the system
action Init:
    store = KeyValueStore()

# Assertions to check properties
always assertion SequenceNumberBounded:
    return store.next_seq <= 21

always assertion L0Consistency:
    # L0 should only contain non-empty immutable memtables
    for level in store.l0:
        if len(level) == 0:
            return False
    return True

always assertion MonotonicSequenceNumbers:
    # Sequence numbers should always be monotonically increasing
    for i in range(len(store.memtable) - 1):
        if store.memtable[i][2] >= store.memtable[i + 1][2]:
            return False
    for i in range(len(store.immutable_memtable) - 1):
        if store.immutable_memtable[i][2] >= store.immutable_memtable[i + 1][2]:
            return False
    for level in store.l0:
        for i in range(len(level) - 1):
            if level[i][2] >= level[i + 1][2]:
                return False
    return True

always assertion SequenceNumberInvariant:
    # Committed sequence should be less than or equal to next sequence
    return store.last_committed_seq <= store.next_seq

always assertion DurabilityInvariant:
    # Remote persisted sequence should be less than or equal to committed sequence
    return store.last_remote_persisted_seq <= store.last_committed_seq

always eventually assertion WALFlushed:
    # WAL buffer should eventually be empty
    return len(store.wal_buffer) == 0

always eventually assertion MemtableFlushed:
    # Memtable should eventually be empty
    return len(store.memtable) == 0 and len(store.immutable_memtable) == 0

always eventually assertion ImmutableMemtableFlushed:
    # Immutable memtable should eventually be flushed to L0
    return len(store.immutable_memtable) == 0

always assertion BoundedObjects:
    # Total number of objects (WAL files + L0 files) should be bounded
    total_objects = len(store.flushed_wal) + len(store.l0)
    return total_objects <= 10

always assertion ReadDurabilityRespected:
    # Reads with DURABILITY_REMOTE should only see data up to last_remote_persisted_seq
    # This is enforced by the Get action logic, but we can verify the invariant
    return store.last_remote_persisted_seq <= store.last_committed_seq

always assertion StorageConsistency:
    # Ensure that data flows correctly through the storage hierarchy
    # WAL buffer should contain the most recent writes
    # Memtable should contain all writes
    # Immutable memtable should contain frozen writes
    # L0 should contain flushed writes
    return True  # This is a placeholder for more complex consistency checks

always assertion OperationOrdering:
    # Ensure that operations maintain proper ordering
    # Sequence numbers should be unique and strictly increasing
    seen_seqs = []
    for entry in store.memtable + store.immutable_memtable:
        if entry[2] in seen_seqs:
            return False
        seen_seqs.append(entry[2])
    for level in store.l0:
        for entry in level:
            if entry[2] in seen_seqs:
                return False
            seen_seqs.append(entry[2])
    return True